
==============================================================================================================================
		  *简要说明
	*名字：IFindElement (接口)
	
	*用途：派生类实现算法，用于完成在htmldocument中查找各种元素的目的。
	
	*名字：CFindNovel (小说查找算法)
	
	*用途：继承IFindElement接口，通过计算在htmldocument中获取小说正文节点
		
	*名字：CConfigFindElement (节点查找)
	
	*用途：继承IFindElement接口，通过传入的节点位置，在htmldocument中获取相应位置的Element
==================================================================================================================================

			*实现思路

	*CFindNovel	（小说查找算法）
	
		*必须达成的条件（小说正文Element结构特点）:
					  *1.有多个子节点.
					  *2.子节点大部分有相同的结构（ps:这里的结构指的是有相同个数的子节点）
					  
		*非必须达成条件：（此类条件需要统计获取阀值以提高效率，如：小说正文内容与整个网站内容的比例）
					  *1.字符串长度大于一定比例（过滤掉拥有较小字符串的节点）。（ps:这里的比例指父节点字符串长度除以子节点个数）
					  *2.小说节点的多个子节点为<p>或<br>类型。
		
		*思路：
		
				*获取小说节点：
			*1.通过CFindNovel::EnumElement函数枚举小说节点，
			*2.通过约束条件找到符合 《必须达成的条件》 的节点，参考CFindNovel::IsSingleModel。
			
				*去掉保护信息：
			*记录小说每句话的子节点个数，如果有保护信息，每句话的子节点个数应该>1 这时认为该小说有保护信息，执行DeleteExString操作，删除保护信息。
			详情请参照函数：EnumElement IsSingleModel DeleteExString，
			
				*记录节点位置：
			*在逐个遍历节点的同时记录每层的节点位置。
			
		*提示：
			*该算法只适用于抓取小说正文。
			*对于新闻或其他带有评论功能的网站不能保证准确抓取正文。（通用算法参考优化方案）
			
		*优化方案（目前代码并未实现）：
		
			*1.解决新闻等带有评论的网站不能准确抓取的问题.
				*原因：带评论的网站会有多条评论信息，每条评论为一个子节点，并且每条评论结构一样，符合小说正文特点（有多个子节点，子节点大部分有相同的结构），
					   所以在过滤时容易造成混乱。难以区分。
				*解决办法：根据调研，评论信息会带有大量html文本.
						   概念：正文密度 = 正文长度 / html长度；
						   小说特点：正文密度较大，
						   评论信息特点：正文密度小于小说。
						   当进行前两个条件的筛选得到的结果不唯一时，比较正文密度最大的节点，认为是小说节点。
						   
			*2.关于<p>或<br>判定的不确定性.
				*原因：新闻网站中，正文内容经常会带有大量链接节点，可能出现如下情形： （链接，节点数） > （正文每句话，节点数）
					   当出现上诉情况时，目前算法用于清理保护信息的计数 数组m_arryChildren会给出错误的信息。
					   所以在执行IsStringTagOk 函数时发现拥有相同类型并且数量最多的子节点不符合<br><p>结构，故被过滤掉。
				*解决办法：引入正文密度概念，去掉<br><p>结构的认定
						  
			*3.关于优化加速
				*目标：设定一些阀值。减少递归和函数的调用。以提高效率。
				
				*方法：可参考机器学习方法,参考博客： http://www.cnblogs.com/lexus/archive/2010/10/08/1845806.html
				
	*CConfigFindElement	（节点查找）
	
		*思路：
			通过位置快速从HTMLDocument中找到相应的Element
	